import argparse
import random

def encode(shellcode: str) -> bytearray:

    encoded_shellcode = bytearray()

    with open(shellcode, 'rb') as f:

        shellcode = f.read()

        print("[+] Original shellcode")
        x = "".join([f"\\x{x:02x}" for x in shellcode])
        print(f"{x}\n")

        for b in shellcode:

            encoded_shellcode.append(b)

            x = random.choice(range(1,255))
            encoded_shellcode.append(x)

    encoded_shellcode.append(255)

    assert encoded_shellcode.count(255) == 1

    return encoded_shellcode

def main():

    parser = argparse.ArgumentParser(description='Encode shellcode using the NOT operator')
    parser.add_argument('--shellcode', help='Path to the file containing the shellcode', required=True)
    parser.add_argument('--output', help='Output file', required=False)

    args = parser.parse_args()

    shellcode = args.shellcode
    output_file = args.output

    encoded_shellcode = encode(shellcode)

    print(f"[+] Length of the encoded shellcode: {len(encoded_shellcode)}")

    if 0x00 in encoded_shellcode:
        
        print("[!] Found NULL byte in encoded shellcode")

    if output_file:

        with open(output_file, 'wb') as f:

            f.write(encoded_shellcode)

    else:

        print("[+] Output for C programs:")
        x = "".join([f"\\x{x:02x}" for x in encoded_shellcode])
        print(x)

        print("\n[+] Output for NASM files:")
        x = ",".join([f"0x{x:02x}" for x in encoded_shellcode])
        print(x)


if __name__ == "__main__":

    main()
